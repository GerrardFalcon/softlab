"""
Definitions of classes manipulation expriment data, including:

- ``DataChart`` is the holder of a chart generated from data analysis
- ``DataRecord`` holds a data table of related parameters
- ``DataGroup`` represents group of all data records in one activity
"""
from typing import (
    Any,
    Dict,
    Tuple,
    Optional,
    Sequence,
    Union,
)
import imageio.v3 as iio
import numpy as np
import pandas as pd
import uuid
import datetime as dt
from softlab.jin import match_dataframes

class DataChart():
    """
    Holder of a chart which is normally generated by data analysis

    Arguments:
    title -- title of chart
    
    Properties:
    title -- title of chart, gettable, settable
    figure -- chart data array, gettable, but can't be set directly
    """
    def __init__(self, title: str):
        self.title = title
        self._figure = np.zeros((2, 2), dtype='uint8')

    @property
    def title(self) -> str:
        """Get title of chart"""
        return self._title

    @title.setter
    def title(self, title: str) -> None:
        """Set title of chart"""
        title = str(title)
        if len(title) == 0:
            raise ValueError('DataChart needs a non-empty title')
        self._title = str(title)

    @property
    def figure(self) -> np.ndarray:
        """Get data array of chart"""
        return self._figure

    @figure.setter
    def figure(self, figure: np.ndarray) -> None:
        """Set data array of chart"""
        if isinstance(figure, np.ndarray) and figure.size > 0:
            self._figure = figure
        else:
            raise ValueError(f'{figure} should be non-empty numpy ndarray')
        
    @property
    def shape(self) -> Tuple:
        return self.figure.shape

    def read(self, uri, index=None, plugin=None, format_hint=None,
             **kwargs: Any) -> None:
        """
        Read chart data from a given source,
        the arguments' requirement is same with imageio.v3.imread
        """
        self._figure = iio.imread(
            uri, index=index, plugin=plugin,
            format_hint=format_hint, **kwargs,
        )

    def write(self, uri, plugin=None, format_hint=None, **kwargs) -> None:
        """
        Write chart data to a given destination,
        the arguments' requirement is same with imageio.v3.imwrite
        """
        iio.imwrite(
            uri, self._figure,
            plugin=plugin, format_hint=format_hint, **kwargs,
        )

    def copy(self) -> Any:
        """Generate a copy of self"""
        other = DataChart(self._title)
        other.figure = self._figure
        return other
    
    def snapshot(self) -> Dict[str, Any]:
        return {
            'title': self.title,
            'shape': self.figure.shape,
        }

class DataRecord():
    """
    Holder of a data record of related parameters, its value is
    a data table in form of a pandas DataFrame. A data record has
    its name and each column has a name (column head), a label
    and an unit. Except data and extra information, a data record
    contains its relevant charts, too.

    Arguments:
    name -- name of record
    columns -- information of all columns, each column includes 4 parts:
        - name
            name of column, corresponding to column head in table, necessary
        - label
            display label, optional, default is an empty string
        - unit
            display unit, optional, default is an empty string
        - dependent
            whether the column represents a dependent parameter, type is
            boolean, optional, default is False

    Properties:
    name -- name of record
    table -- data table
    columns -- information of all columns
    shape -- shape of data table, not settable
    charts -- list of relevant chart titles, not settable

    **Note**: set ``columns`` property will re-initialize the whole table
    """

    def __init__(self, name: str,
                 columns: Sequence[Dict[str, Any]] = [],
                 data: Optional[np.ndarray] = None) -> None:
        self.name = name
        self._columns: Sequence[Dict[str, Any]] = []
        self._table = pd.DataFrame()
        self._charts: Dict[str, DataChart] = {}
        self.prepare_columns(columns, data)

    @property
    def name(self) -> str:
        """Get name of record"""
        return self._name

    @name.setter
    def name(self, name: str) -> None:
        """Set name of record"""
        name = str(name)
        if len(name) == 0:
            raise ValueError('Name must be non-empty string')
        self._name = name

    @property
    def table(self) -> pd.DataFrame:
        """Get data table"""
        return self._table.copy()

    @table.setter
    def table(self, other: pd.DataFrame) -> None:
        """Set data table"""
        if not isinstance(other, pd.DataFrame):
            raise TypeError(f'Invalid record table type: {type(other)}')
        if not match_dataframes(other, self._table):
            raise ValueError('Table columns don\'t match')
        self._table = other.copy()

    @property
    def columns(self) -> Sequence[Dict[str, Any]]:
        """Get information of all columns"""
        return self._columns

    @columns.setter
    def columns(self, other: Sequence[Dict[str, Any]]) -> None:
        """Re-initialize all columns"""
        self.prepare_columns(other)

    @property
    def shape(self) -> Tuple:
        """Shape of data table"""
        return self._table.shape
    
    def snapshot(self) -> Dict[str, Any]:
        return {
            'name': self.name,
            'columns': self.columns,
            'shape': self.shape,
            'charts': dict(map(
                lambda title: (title, self._charts[title].snapshot()),
                self._charts,
            ))
        }

    def copy(self) -> Any:
        """Get a copy of self"""
        record_copy = DataRecord(self.name, self.columns)
        record_copy.add_rows(self.table)
        for _, chart in self._charts.items():
            record_copy.add_chart(chart)
        return record_copy

    def row(self, index: int) -> Dict[str, Any]:
        """Get row of given index"""
        if index >= 0 and index < len(self._table.index):
            return self._table.loc[self._table.index[index]].to_dict()
        return {}

    def column(self, name: str) -> pd.DataFrame:
        """Get column of given name"""
        if name in self._table.columns:
            return self._table[[name]].copy()
        return pd.DataFrame()

    def dependents(self) -> pd.DataFrame:
        """Get data of all dependent variables"""
        columns = list(map(
            lambda col: col['name'],
            filter(
                lambda col: col['dependent'],
                self._columns,
            )
        ))
        if len(columns) > 0:
            return self._table.loc[:, columns]
        else:
            print('No dependent variables')
            return pd.DataFrame()

    def independents(self) -> pd.DataFrame:
        """Get data of all independent variables"""
        columns = list(map(
            lambda col: col['name'],
            filter(
                lambda col: not col['dependent'],
                self._columns,
            )
        ))
        if len(columns) > 0:
            return self._table.loc[:, columns]
        else:
            print('No independent variables')
            return pd.DataFrame()

    def prepare_columns(self,
                        columns: Sequence[Dict[str, Any]] = [],
                        data: Optional[np.ndarray] = None) -> None:
        """
        Prepare columns of data table.

        Arguments:
        columns -- information of all columns
        data -- optional initial data

        **Note**: preparation of columns will erase all previous data.
        """
        filtered = filter(
            lambda col: 'name' in col and len(str(col['name'])) > 0,
            columns,
        )
        self._columns = list(map(
            lambda col: {
                'name': str(col['name']),
                'label': str(col.get('label', '')),
                'unit': str(col.get('unit', '')),
                'dependent': bool(col.get('dependent', False)),
            },
            filtered,
        ))
        headers = list(map(lambda col: col['name'], self._columns))
        if isinstance(data, np.ndarray):
            shape = data.shape
            if len(shape) == 2 and shape[1] == len(self._columns):
                self._table = pd.DataFrame(data, columns=headers)
            else:
                raise ValueError(f'Shape of data is invalid: {shape}')
        else:
            self._table = pd.DataFrame(columns=headers)

    def add_rows(self, row: Union[pd.DataFrame, Dict[str, Any]]) -> None:
        """
        Append any count rows in data table
        
        Arguments:
        row -- row data, either a dictionary of all columns' data
               or a DataFrame with same columns
        """
        try:
            if isinstance(row, pd.DataFrame):
                new_rows = row
            elif isinstance(row, Dict):
                try:
                    new_rows = pd.DataFrame(row)
                except:
                    new_rows = pd.DataFrame([row])
            else:
                raise ValueError(f'Type of row is invalid {type(row)}')
            if not match_dataframes(self._table, new_rows):
                raise ValueError('Columns of the added rows don\'t match')
            if len(self._table) > 0:
                data_types = {col: self._table[col].dtype \
                                for col in self._table.columns}
            else:
                data_types = {col: new_rows[col].dtype \
                                for col in self._table.columns}
            self._table = pd.concat([self._table, new_rows], ignore_index=True)\
                .astype(data_types)
        except Exception:
            print(self._columns)
            print(row)
            raise

    def add_column(
            self, name: str,
            data: Union[np.ndarray, pd.Series, pd.DataFrame],
            label: str = '', unit: str = '', dependent: bool = False,
    ) -> None:
        """
        Append a column in data table

        Arguments:
        name -- name of column
        label -- label of column
        unit -- unit of column
        data -- data of column, should match the size of existing table
        """
        head = str(name)
        if len(head) == 0:
            raise ValueError(f'Column name must be non-empty string')
        elif head in self._table.columns:
            raise ValueError(f'Column {name} has exised')
        if len(self._table) == 0:
            headers = self._table.columns
            headers.append(head)
            self._table = pd.DataFrame(columns=headers)
        else:
            try:
                if len(self._table) != data.shape[0]:
                    raise ValueError(f'Length of the new column {name}'
                                     f'does not match the table.')
                if isinstance(data, pd.DataFrame):
                    self._table[head] = data[head]
                else:
                    df = pd.DataFrame(
                        data, columns=[head],
                        index=self._table.index,
                    )
                    self._table[head] = df[head]
            except Exception:
                print(f'Data of new column {name} is invalid')
                raise
        self._columns.append({
            'name': head,
            'label': str(label),
            'unit': str(unit),
            'dependent': bool(dependent),
        })

    @property
    def charts(self) -> Sequence[str]:
        """Get list of all chart titles"""
        return list(self._charts.keys())

    def chart(self, title: str) -> Optional[DataChart]:
        """Get chart with given title"""
        if title in self._charts:
            return self._charts[title].copy()
        else:
            return None

    def add_chart(self, chart: DataChart) -> None:
        """Add or update a chart"""
        if isinstance(chart, DataChart):
            self._charts[chart.title] = chart.copy()
        else:
            raise ValueError(f'chart must be a DataChart instance')

    def clear_charts(self) -> None:
        """Clear all charts"""
        self._charts.clear()

    def pop_chart(self, title: str) -> DataChart:
        """Get and remove the chart with the given title from record"""
        return self._charts.pop(title)

    def remove_chart(self, title: str) -> None:
        """remove chart with given title"""
        try:
            self.pop_chart(title)
        except Exception:
            print(f'No chart with the title "{title}"')

    def remove_charts(self, titles: Sequence[str]) -> None:
        """remove charts with given titles"""
        for title in titles:
            self.remove_chart(title)

class DataGroup():
    """
    Holder of all data records in one activity.
    Each data group has its own ID of type uuid.UUID.

    Arguments:
    name --- name of group, non-empty string
    id --- ID of group
    meta --- metadata of data group

    Properties:
    name --- name of group
    id --- ID of group
    backend --- information of backend, including type and arguments
    records --- name list of containing records
    """
    def __init__(self,
                 name: str,
                 id: Optional[uuid.UUID] = None,
                 meta: Optional[Dict[str, Any]] = None,
    ) -> None:
        self.name = name
        self._id = id if isinstance(id, uuid.UUID) else uuid.uuid4()
        self._timestamp = dt.datetime.now()
        self._meta: Dict[str, Any] = {}
        if isinstance(meta, Dict):
            for key, value in meta.items():
                key = str(key)
                if len(key) > 0:
                    meta[key] = value
        self._backend = {
            'type': '', 'arguments': {},
        }
        self._records: Dict[str, DataRecord] = {}
        
    @property
    def name(self) -> str:
        """Get group name"""
        return self._name
    
    @name.setter
    def name(self, name: str) -> None:
        name = str(name)
        if len(name) == 0:
            raise ValueError('Name must be non-empty string')
        self._name = name

    @property
    def id(self) -> uuid.UUID:
        """Get group ID"""
        return self._id
    
    @id.setter
    def id(self, id: uuid.UUID) -> None:
        """Set group ID"""
        if not isinstance(id, uuid.UUID):
            raise TypeError(f'Type of ID must be uuid.UUID: {id} {type(id)}')
        self._id = id

    @property
    def timestamp(self) -> dt.datetime:
        """Get timestamp of activity"""
        return self._timestamp
    
    @timestamp.setter
    def timestamp(self, ts: Union[dt.datetime, float, str]) -> None:
        """
        Set timestamp of acitvity

        Arguments:
        - ts --- timestamp, 4 possiple forms:
            - datetime.datetime instance
            - float value representing the seconds since 1970-01-01 00:00:00
            - string 'now' or 'current'
            - string with the format
              ``YYYY-MM-DD[*HH[:MM[:SS[.fff[fff]]]][+HH:MM[:SS[.ffffff]]]]``
        """
        if isinstance(ts, dt.datetime):
            self._timestamp = ts
        elif isinstance(ts, float):
            self._timestamp = dt.datetime.fromtimestamp(ts)
        elif isinstance(ts, str):
            if ts == 'now' or ts == 'current':
                self._timestamp = dt.datetime.now()
            else:
                self._timestamp = dt.datetime.fromisoformat(ts)
        else:
            raise TypeError(f'Timestamp type is invalid: {type(ts)}')

    @property
    def backend(self) -> Dict[str, Any]:
        """Get backend information"""
        return self._backend
    
    @backend.setter
    def backend(self, backend: Dict[str, Any]) -> None:
        """
        Set backend information

        Arguments:
        backend -- backend information, dictionary, must has type (string)
                   and optional arguments (dictionary) attributes
        """
        if isinstance(backend, Dict):
            if not 'type' in backend or len(str(backend['type'])) == 0:
                raise ValueError(f'No valid type in setting: {backend}')
            if 'arguments' in backend and \
                    not isinstance(backend['arguments'], Dict):
                raise ValueError(f'Arguments in setting must be dict')
            self._backend = backend
        else:
            raise TypeError(f'Invalid backend setting type: {type(backend)}')

    @property
    def meta(self) -> Dict[str, Any]:
        """Get metadata of group"""
        return self._meta
    
    def update_meta(self, key: str, value: Any) -> None:
        """
        Update metadata with ``key`` and ``value``
        
        ``key`` must be non-empty string. If ``value`` is None, the metadata
        with the ``key`` will be removed.
        """
        key = len(key)
        if len(key) == 0:
            raise ValueError('Key of metadata must be non-empty')
        if value is None:
            self._meta.pop(key, '_')
        self._meta[key] = value

    def snapshot(self) -> Dict[str, Any]:
        return {
            'name': self._name,
            'id': str(self._id),
            'timestamp': self._timestamp,
            'backend': self._backend,
            'meta': self._meta,
            'records': dict(map(
                lambda key: (key, self._records[key].snapshot()),
                self._records,
            )),
        }
    
    @property
    def records(self) -> Sequence[str]:
        """Get name list of containing records"""
        return list(self._records.keys())
    
    def record(self, name: str) -> Optional[DataRecord]:
        """Get record with the given name"""
        if name in self._records:
            return self._records[name].copy()
        else:
            return None

    def add_record(self, record: DataRecord) -> None:
        """Add or update a record"""
        if isinstance(record, DataRecord):
            self._records[record.name] = record
        else:
            raise ValueError(f'record must be a DataRecord instance')

    def clear_records(self) -> None:
        """Clear all records"""
        self._records.clear()
    
    def pop_record(self, name: str) -> DataRecord:
        """Get and remove the record with the given name from group"""
        return self._records.pop(name)

    def remove_record(self, name: str) -> None:
        """remove record with given name"""
        try:
            self.pop_record(name)
        except Exception:
            print(f'No record with the name "{name}"')
    
    def remove_records(self, names: Sequence[str]) -> None:
        """remove records with given names"""
        for name in names:
            self.remove_record(name)

if __name__ == '__main__':
    from pprint import pprint
    columns = [
        {'name': 'x',
         'label': 'x',
         'dependent': False},
        {'name': 'y',
         'label': 'y',
         'dependent': True}
    ]
    data = np.array([[1, 1],
                     [2, 4],
                     [3, 9],
                     [4, 16]])
    dr1 = DataRecord('dr1', columns, data)
    dr1.add_rows(pd.DataFrame([[5, 25]], columns=['x', 'y']))
    dr1.add_rows({'x': [6, 7], 'y': [36, 49]})
    dr1.add_column('z', pd.DataFrame([[1], [8], [27], [64], [125], [216], [1]],
                                      columns=['z']), label='z')
    print(dr1.table)
    print(dr1.table.dtypes)

    dr1_copy = dr1.copy()
    dr1_copy.add_column('a', np.arange(7).astype(np.float32))
    dr1_copy.add_rows(pd.DataFrame(np.random.randint(100, size=(10, 4)), 
                                   columns=['x', 'y', 'z', 'a']))
    pprint(dr1_copy.snapshot())
